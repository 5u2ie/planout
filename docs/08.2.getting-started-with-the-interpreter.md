---
id: getting-started-with-the-interpreter
title: Getting started with the interpreter
layout: docs
permalink: /docs/getting-started-with-the-interpreter.html
prev: planout-language.html
next: planout-language-reference.html
---

This getting started guide is based off of the
[PlanOut tutorial IPython notebook](https://github.com/facebook/planout/tree/master/contrib/pydata14_tutorial)
from PyData '14.

The PlanOut language provides a few simple constructs for defining experiments.
It looks similar to JavaScript, and uses familiar names for the random assignment
operators.

```javascript
btton_text = uniformChoice(choices=['Purchase', 'Buy'], unit=userid);
has_discount = bernoulliTrial(p=0.3, unit=userid);
```

To compile this code, you might write it to a file (say, `myfile.planout`), and type something like:

```
node planout.js myfile.planout
```

Serialized PlanOut code
The PlanOut language gets compiled into JSON, which can be loaded into Python as a dictionary and run by the interpreter.

Here is what PlanOut code looks like when it gets compiled into the serialization.

```python
serial = compile("""
  button_text = uniformChoice(choices=['Purchase','Buy'], unit=userid);
  has_discount = bernoulliTrial(p=0.3, unit=userid);
""")
serial
Out[2]:
{u'op': u'seq',
 u'seq': [{u'op': u'set',
   u'value': {u'choices': {u'op': u'array', u'values': [u'Purchase', u'Buy']},
    u'op': u'uniformChoice',
    u'unit': {u'op': u'get', u'var': u'userid'}},
   u'var': u'button_text'},
  {u'op': u'set',
   u'value': {u'op': u'bernoulliTrial',
    u'p': 0.3,
    u'unit': {u'op': u'get', u'var': u'userid'}},
   u'var': u'has_discount'}]}
```

## Running serialized PlanOut code
The Interpreter object executes a dictionary containing serialized PlanOut code. Interpreter has three required arguments:
 - A dictionary containing serialized PlanOut code

 - An experiment-level salt

 - Input data

 - An optional environment


Let's run the serialized code above with userid 4.

```python
from planout.interpreter import *

i = Interpreter(serial, 'my_salt', {'userid':4})
dict(i.get_params())
```

```
{u'button_text': u'Purchase', u'has_discount': 0}
```

And with a few more users...

```python
for i in xrange(5):
    print i, Interpreter(serial, 'my_salt', {'userid':i}).get_params()
```

Outputs

```
0 {u'button_text': u'Buy', u'has_discount': 0}
1 {u'button_text': u'Buy', u'has_discount': 0}
2 {u'button_text': u'Purchase', u'has_discount': 0}
3 {u'button_text': u'Purchase', u'has_discount': 0}
4 {u'button_text': u'Purchase', u'has_discount': 0}
```

## SimpleInterpretedExperiment for serialized PlanOut scripts
The SimpleInterpretedExperiment object behaves like a SimpleExperiment object, except rather than defining an execute() procedure, one defines a method that loads a script script.

```python
from planout.experiment import SimpleInterpretedExperiment

scriptCode = compile(
  """
    button_text = uniformChoice(choices=['Purchase','Buy'], unit=userid);
    has_discount = bernoulliTrial(p=0.3, unit=userid);
  """
)

class IExp1(SimpleInterpretedExperiment):
    def setup(self):
      self.script = scriptCode
```

Let's try out the experiment:

```python
for i in xrange(5):
    e = IExp1(userid=i)
    print i, e.get_params()
```

which outputs (fille in) ...

```
0 {u'button_text': u'Purchase', u'has_discount': 0}
1 {u'button_text': u'Buy', u'has_discount': 0}
2 {u'button_text': u'Purchase', u'has_discount': 0}
3 {u'button_text': u'Buy', u'has_discount': 1}
4 {u'button_text': u'Purchase', u'has_discount': 0}
```

This is probably pretty close to something you'd like to use in a production setting.
Other ways of generating serialized experiments
Serialized PlanOut code can also be generated automatically, including via user interfaces.
Let's consider a hypothetical graphical user interface for constructing full factorial experiments. We assume that the users' Web front end makes an AJAX request to the server, and sends a dictionary whose keys are factors (parameters) and values are lists of possible values.

We would then use a function like this to generate PlanOut code for the given input data

```python
def serialize_full_factorial(x, unit='userid'):
    items = []
    for k,v in x.iteritems():
        items.append({
          "op": "set", "var": k,
          "value": {
           "op": "uniformChoice", "choices": v,
           "unit": {
             "op": "get", "var": unit
           }
          }
        })
    return {"op":"seq", "seq": items}
```

Here is an example configuration file that might be generated by the GUI, and how it gets transformed into PlanOut code.

```python
my_config = {'button_text':['Post', 'Share', 'X'], 'button_color':['#00ff00', '#aaaaaa']}
serialize_full_factorial(my_config)
```

Emits,

```
{'op': 'seq',
 'seq': [{'op': 'set',
   'value': {'choices': ['#00ff00', '#aaaaaa'],
    'op': 'uniformChoice',
    'unit': {'op': 'get', 'var': 'userid'}},
   'var': 'button_color'},
  {'op': 'set',
   'value': {'choices': ['Post', 'Share', 'X'],
    'op': 'uniformChoice',
    'unit': {'op': 'get', 'var': 'userid'}},
   'var': 'button_text'}]}
```

We can generate experiments on the fly from the configuration file:

```python
def gen_exp(experiment_name, config, **inputs):
    e = SimpleInterpretedExperiment(**inputs)
    e.name = experiment_name
    e.salt = experiment_name
    e.script = serialize_full_factorial(config)
    return e
```

Now let's perform some random assignments. You can also see the log file, my-generated-experiment.log.

```python
for i in xrange(5):
    print i, gen_exp('custom_experiment', my_config, userid=i).get_params()
```

ouputs
```
0 {'button_color': '#aaaaaa', 'button_text': 'X'}
1 {'button_color': '#aaaaaa', 'button_text': 'Share'}
2 {'button_color': '#aaaaaa', 'button_text': 'X'}
3 {'button_color': '#aaaaaa', 'button_text': 'Post'}
4 {'button_color': '#aaaaaa', 'button_text': 'Post'}
```
