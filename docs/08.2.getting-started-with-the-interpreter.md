---
id: getting-started-with-the-interpreter
title: Getting started with the interpreter
layout: docs
permalink: /docs/getting-started-with-the-interpreter.html
prev: planout-language.html
next: planout-language-reference.html
---

The PlanOut language provides a few simple constructs for defining experiments.
It looks similar to JavaScript, and uses familiar names for the random assignment
operators.

```javascript
btton_text = uniformChoice(choices=['Purchase', 'Buy'], unit=userid);
has_discount = bernoulliTrial(p=0.3, unit=userid);
```

To compile this code, you might write it to a file (say, `myfile.planout`), and type something like:

```
node planout.js myfile.planout
```

Serialized PlanOut code
The PlanOut language gets compiled into JSON, which can be loaded into Python as a dictionary and run by the interpreter.

Here is what PlanOut code looks like when it gets compiled into the serialization.

```python
  button_text = uniformChoice(choices=['Purchase','Buy'], unit=userid);
  has_discount = bernoulliTrial(p=0.3, unit=userid);
```

```json
{
  "op": "seq",
  "seq": [
    {
      "op": "set",
      "var": "button_text",
      "value": {
        "choices": {
          "op": "array",
          "values": [
            "Purchase",
            "Buy"
          ]
        },
        "unit": {
          "op": "get",
          "var": "userid"
        },
        "op": "uniformChoice"
      }
    },
    {
      "op": "set",
      "var": "has_discount",
      "value": {
        "p": 0.3,
        "unit": {
          "op": "get",
          "var": "userid"
        },
        "op": "bernoulliTrial"
      }
    }
  ]
}
```

## The `SimpleInterpretedExperiment` class
The SimpleInterpretedExperiment object behaves like a SimpleExperiment object, except rather than defining an execute() procedure, one defines a method that loads a script script.

```python
from planout.experiment import SimpleInterpretedExperiment

scriptCode = compile(
  """
    button_text = uniformChoice(choices=['Purchase','Buy'], unit=userid);
    has_discount = bernoulliTrial(p=0.3, unit=userid);
  """
)

class Exp1(SimpleInterpretedExperiment):
    def setup(self):
      self.script = scriptCode
```

Let's try out the experiment:

```python
for i in xrange(5):
    e = Exp1(userid=i)
    print i, e.get_params()
```

which outputs (fille in) ...

```
0 {u'button_text': u'Purchase', u'has_discount': 0}
1 {u'button_text': u'Buy', u'has_discount': 0}
2 {u'button_text': u'Purchase', u'has_discount': 0}
3 {u'button_text': u'Buy', u'has_discount': 1}
4 {u'button_text': u'Purchase', u'has_discount': 0}
```

This is probably pretty close to something you'd like to use in a production setting.
Other ways of generating serialized experiments
Serialized PlanOut code can also be generated automatically, including via user interfaces.
Let's consider a hypothetical graphical user interface for constructing full factorial experiments. We assume that the users' Web front end makes an AJAX request to the server, and sends a dictionary whose keys are factors (parameters) and values are lists of possible values.

We would then use a function like this to generate PlanOut code for the given input data

```python
def serialize_full_factorial(x, unit='userid'):
    items = []
    for k,v in x.iteritems():
        items.append({
          "op": "set", "var": k,
          "value": {
           "op": "uniformChoice", "choices": v,
           "unit": {
             "op": "get", "var": unit
           }
          }
        })
    return {"op":"seq", "seq": items}
```

Here is an example configuration file that might be generated by the GUI, and how it gets transformed into PlanOut code.

```python
my_config = {'button_text':['Post', 'Share', 'X'], 'button_color':['#00ff00', '#aaaaaa']}
serialize_full_factorial(my_config)
```

Emits,

```
{'op': 'seq',
 'seq': [{'op': 'set',
   'value': {'choices': ['#00ff00', '#aaaaaa'],
    'op': 'uniformChoice',
    'unit': {'op': 'get', 'var': 'userid'}},
   'var': 'button_color'},
  {'op': 'set',
   'value': {'choices': ['Post', 'Share', 'X'],
    'op': 'uniformChoice',
    'unit': {'op': 'get', 'var': 'userid'}},
   'var': 'button_text'}]}
```

We can generate experiments on the fly from the configuration file:

```python
def gen_exp(experiment_name, config, **inputs):
    e = SimpleInterpretedExperiment(**inputs)
    e.name = experiment_name
    e.salt = experiment_name
    e.script = serialize_full_factorial(config)
    return e
```

Now let's perform some random assignments. You can also see the log file, my-generated-experiment.log.

```python
for i in xrange(5):
    print i, gen_exp('custom_experiment', my_config, userid=i).get_params()
```

ouputs
```
0 {'button_color': '#aaaaaa', 'button_text': 'X'}
1 {'button_color': '#aaaaaa', 'button_text': 'Share'}
2 {'button_color': '#aaaaaa', 'button_text': 'X'}
3 {'button_color': '#aaaaaa', 'button_text': 'Post'}
4 {'button_color': '#aaaaaa', 'button_text': 'Post'}
```

For more on the mechanics of working with the lower-level interpreter class, see the
[PlanOut tutorial IPython notebook](https://github.com/facebook/planout/tree/master/contrib/pydata14_tutorial)
from PyData '14.
